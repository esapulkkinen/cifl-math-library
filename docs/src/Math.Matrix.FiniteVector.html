<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="">&gt;{-# LANGUAGE Safe,DataKinds, MultiParamTypeClasses, GADTs, FlexibleInstances, FlexibleContexts, UndecidableInstances, TypeOperators, KindSignatures, TypeFamilies, ExistentialQuantification, ScopedTypeVariables, TypeOperators, AllowAmbiguousTypes #-}
&gt;{-# OPTIONS_GHC -cpp #-}
&gt;module Math.Matrix.FiniteVector where
&gt;import Control.Applicative
&gt;import Math.Matrix.Interface
&gt;import GHC.TypeLits

&gt;data Vec :: Nat -&gt; * -&gt; * where
&gt;  Empty :: Vec 0 a 
&gt;  Cons :: a -&gt; Vec n a -&gt; Vec (1 + n) a
&gt;  Assoc :: Vec (n + (m + p)) a -&gt; Vec ((n + m) + p) a

&gt;vzero_vec = Empty
&gt; 
&gt;vnegate_vec :: (Num a) =&gt; Vec n a -&gt; Vec n a
&gt;vnegate_vec = fmap negate

&gt;class Appendable n m where
&gt;   vplus :: Vec n a -&gt; Vec m a -&gt; Vec (n + m) a

&gt;instance Appendable 0 0 where
&gt;   vplus Empty Empty = Empty

&gt;instance Appendable n 0 where
&gt;   vplus v Empty = v

&gt;instance Appendable 0 n where
&gt;   vplus Empty v = v

&gt;instance Functor (Vec n) where
&gt;   fmap f Empty = Empty
&gt;   fmap f (Cons x xr) = Cons (f x) (fmap f xr)

&gt;vlength :: Vec n a -&gt; Integer
&gt;vlength Empty = 0
&gt;vlength (Cons _ r) = 1 + vlength r

&gt;vhead :: Vec (1+n) a -&gt; a
&gt;vhead (Cons x _) = x

vtail :: (KnownNat n) =&gt; Vec (1+n) a -&gt; Vec n a
vtail (Cons _ r) = r

Doesn't typecheck in GHC 7.10.3, &quot;Could not deduce (n1 ~ n) from the context
((1+n1) ~ (1+n)).

&gt;foldv :: b -&gt; (a -&gt; b -&gt; b) -&gt; Vec n a -&gt; b
&gt;foldv e _ Empty = e
&gt;foldv e f (Cons x xr) = f x (foldv e f xr)

&gt;sum_vcoordinates :: (Num a) =&gt; Vec n a -&gt; a
&gt;sum_vcoordinates = foldv 0 (+)

&gt;sum_vsquares :: (Num a) =&gt; Vec n a -&gt; a
&gt;sum_vsquares = foldv 0 (\x y -&gt; x*x + y)

&gt;vtrace :: (Num a, Diagonalizable n) =&gt; (Vec n :*: Vec n) a -&gt; a
&gt;vtrace = sum_vcoordinates . vdiagonal . cells

&gt;toList :: Vec n a -&gt; [a]
&gt;toList = foldv [] (:)

&gt;toListEnc :: EncVec a -&gt; [a]
&gt;toListEnc (EncVec x) = toList x

&gt;data EncVec a = forall n. EncVec (Vec n a)

&gt;instance (Show a) =&gt; Show (EncVec a) where
&gt;  show (EncVec Empty) = &quot;&quot;
&gt;  show (EncVec (Cons x xr)) = show x ++ &quot; &quot; ++ show (EncVec xr)

&gt;fromList :: [a] -&gt; EncVec a
&gt;fromList [] = EncVec Empty
&gt;fromList (x:xr) = case fromList xr of { (EncVec v) -&gt; EncVec $ Cons x v }

&gt;instance (Diagonalizable n , VectorSpace (Vec n a), Transposable (Vec n) (Vec n), Num a) =&gt; SquareMatrix (Vec n) a where
&gt;   identity = Matrix videntity
&gt;   diagonal_matrix x = Matrix (vdiagonal_matrix x)
&gt;   diagonal (Matrix x) = vdiagonal x

&gt;class Diagonalizable n where
&gt;   vnull :: (Num a) =&gt; Vec n a
&gt;   vdiagonal :: Vec n (Vec n a) -&gt; Vec n a
&gt;   videntity :: (Num a) =&gt; Vec n (Vec n a)
&gt;   vdiagonal_matrix :: (Num a) =&gt; Vec n a -&gt; Vec n (Vec n a)

&gt;instance Diagonalizable 0 where
&gt;   vnull = Empty
&gt;   vdiagonal Empty = Empty
&gt;   videntity = Empty
&gt;   vdiagonal_matrix Empty = Empty

&gt;instance (Show a) =&gt; Show (Vec n a) where
&gt;  show Empty = &quot;&quot;
&gt;  show (Cons x xr) = show x ++ &quot; &quot; ++ show xr

&gt;instance Show (((Vec 0) :*: (Vec n)) a) where
&gt;  show (Matrix Empty) = &quot;&quot;


&gt;bindv :: (Diagonalizable n, Functor (Vec n)) =&gt; Vec n a -&gt; (a -&gt; Vec n b) -&gt; Vec n b
&gt;bindv z f = vdiagonal $ fmap f z
</span></pre></body></html>