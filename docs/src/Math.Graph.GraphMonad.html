<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="">&gt;{-# LANGUAGE Safe,RankNTypes #-}
&gt;module Math.Graph.GraphMonad where
&gt;import Data.Monoid
&gt;import Math.Graph.Reversible
&gt;import Math.Graph.InGraphMonad
&gt;import Math.Graph.GraphMonoid

&gt;-- | This monad is based on idea from &quot;Mac Lane: Categories for the working
&gt;-- mathematician&quot; e.g. monad defined by the functor T(A) = G x A, where G
&gt;-- is a group or monoid.

&gt;data GraphM g a = GraphM { runGraphM :: (g,a) }

&gt;instance Functor (GraphM g) where
&gt;   fmap f (GraphM (a,b)) = GraphM (a,f b)

&gt;instance (Monoid g) =&gt; Applicative (GraphM g) where
&gt;   pure x = GraphM $ pure x
&gt;   (GraphM f) &lt;*&gt; (GraphM x) = GraphM $ f &lt;*&gt; x

&gt;instance (Monoid g) =&gt; Monad (GraphM g) where
&gt;  return x = GraphM (mempty,x)
&gt;  (GraphM (a,x)) &gt;&gt;= g = GraphM $ let (GraphM (b,y)) = g x in (mappend a b,y)
&gt;  fail msg = GraphM (mempty,error msg)

&gt;runGraphActionM :: (a -&gt; g -&gt; a) -&gt; GraphM g a -&gt; a
&gt;runGraphActionM f (GraphM (action,res)) = f res action

&gt;actionM :: (Monad m, Ord a) =&gt; Graph mon a -&gt; mon -&gt; a -&gt; m a
&gt;actionM g m x = inGraphM g (x `actM` m)
  
&gt;source :: (Monad m, GraphMonoid mon, Ord a) =&gt; Graph mon a -&gt; a -&gt; m a
&gt;source g = actionM g gdom

&gt;target :: (Monad m, GraphMonoid mon, Ord a) =&gt; Graph mon a -&gt; a -&gt; m a
&gt;target g = actionM g gcod

&gt;inverse :: (Monad m, ReversibleGraphMonoid mon, Ord a) =&gt; Graph mon a -&gt; a -&gt; m a
&gt;inverse g = actionM g gnot


&gt;actMG :: g -&gt; GraphM g ()
&gt;actMG x = GraphM $ (x,())

&gt;data GraphMT m g a = GraphMT { runGraphMT :: (forall b. b -&gt; g -&gt; m b) -&gt; m a }

&gt;instance (Functor m) =&gt; Functor (GraphMT m g) where
&gt;   fmap f (GraphMT x) = GraphMT $ \act -&gt; fmap f (x act)

&gt;instance (Monoid g, Applicative m) =&gt; Applicative (GraphMT m g) where
&gt;   pure x = GraphMT $ \act -&gt; act x mempty
&gt;   (GraphMT f) &lt;*&gt; (GraphMT x) = GraphMT $ \act -&gt; f act &lt;*&gt; x act

&gt;instance (Monoid g, Monad m) =&gt; Monad (GraphMT m g) where
&gt;   return x = GraphMT $ \act -&gt; act x mempty
&gt;   (GraphMT f) &gt;&gt;= g = GraphMT $ \act -&gt; f act &gt;&gt;= \a -&gt; runGraphMT (g a) act
&gt;   fail msg = GraphMT $ \_ -&gt; fail msg

&gt;actMT :: (Monad m) =&gt; g -&gt; GraphMT m g a -&gt; GraphMT m g a
&gt;actMT x (GraphMT f) = GraphMT $ \act -&gt; f act &gt;&gt;= \y -&gt; act y x
</span></pre></body></html>