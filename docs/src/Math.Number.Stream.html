<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="">&gt;{-# Language Trustworthy,UndecidableInstances, ExistentialQuantification, FlexibleInstances, MultiParamTypeClasses, MagicHash, TypeOperators, FlexibleContexts, Arrows, TypeFamilies, OverloadedLists #-}
&gt;-- |
&gt;-- This module implements lazy infinite streams,
&gt;-- stream generating functions and lots of operations on the lazy streams.
&gt;-- some examples for use of this module:
&gt;-- 
&gt;-- @fib = 1 `div` (1 - z - z*z)@
&gt;-- 
&gt;-- @pascal_triangle = Matrix $ 1 `div` (1 - z - z2*z)@
&gt;-- 
&gt;-- @take 4 fib == [1,1,2,3]@
&gt;-- 
&gt;-- @alternating_bits = cycle [0,1]@
&gt;
&gt;module Math.Number.Stream where
&gt;import Data.Monoid
&gt;import Data.Complex
&gt;import qualified Data.Foldable
&gt;import qualified Control.Category as C
&gt;import Control.Applicative
&gt;import Control.Parallel
&gt;import qualified Prelude as P
&gt;import Prelude hiding (zip,unzip, zipWith,cycle,take,filter,drop,zipWith3,sin,cos,either,takeWhile,dropWhile,span,splitAt)
&gt;import Math.Tools.Orthogonal
&gt;import Math.Tools.I
&gt;import Math.Tools.Functor
&gt;import qualified Math.Tools.Arrow as TArrow
&gt;import Math.Tools.Visitor
&gt;import Math.Tools.Median
&gt;import Math.Tools.CoFunctor
&gt;import Math.Matrix.Covector
&gt;import Math.Tools.CoMonad hiding (copy)
&gt;import Math.Tools.PrettyP hiding (empty)
&gt;import Math.Tools.FixedPoint (Rec(..))
&gt;import Math.Tools.Adjunction hiding (swap)
&gt;import Math.Tools.Integer hiding (square_root)
&gt;import qualified Math.Tools.Queue as Q
&gt;import Data.Sequence (Seq, (&lt;|), (|&gt;))
&gt;import qualified Data.Sequence as Seq
&gt;import Math.Tools.Queue (Queue)
&gt;import Control.Arrow
&gt;import Data.Ratio

import qualified Model.Nondeterminism as Nondet

&gt;import qualified Math.Tools.Nondeterministic as Nondeterministic
&gt;import Math.Tools.Universe
&gt;import qualified Data.List as List
&gt;import qualified Math.Matrix.Interface as Matrix
&gt;import Math.Matrix.Interface hiding ((|&gt;))
&gt;import Math.Matrix.Matrix
&gt;import Math.Matrix.Simple
&gt;import qualified Data.Set as Set

&gt;infixr 5 `Pre`

&gt;-- | Data structure of infinite lazy streams.
&gt;data Stream a = Pre { shead :: a, stail_strict :: Stream a }

&gt;stail :: Stream a -&gt; Stream a
&gt;stail ~(Pre _ xr) = xr

&gt;matrix_powers :: (SquareMatrix g a, InnerProductSpace (g a),
&gt;                 Scalar (g a) ~ a) =&gt; (g :*: g) a -&gt; Stream ((g :*: g) a)
&gt;matrix_powers x = Pre identity $ fmap (x %*%) $ matrix_powers x



&gt;matrix_exponential_stream :: (Fractional (Scalar ((g :*: g) a)), Num ((g :*: g) a),
&gt;                      SquareMatrix g a, InnerProductSpace (g a),
&gt;                      VectorSpace ((g :*: g) a), Scalar (g a) ~ a)
&gt;   =&gt; (g :*: g) a -&gt; Stream ((g :*: g) a)
&gt;matrix_exponential_stream x = sum_stream str
&gt;  where str = liftA2 (\x kf -&gt; (1 / kf) %* x) (matrix_powers x) factorial

&gt;-- | &lt;https://en.wikipedia.org/wiki/Matrix_exponential&gt;
&gt;matrix_exponential :: (Fractional (Scalar ((g :*: g) a)),
&gt;                      Num ((g :*: g) a), 
&gt;                      SquareMatrix g a, InnerProductSpace (g a),
&gt;                      VectorSpace ((g :*: g) a), Scalar (g a) ~ a)
&gt;                     =&gt; (g :*: g) a -&gt; (g :*: g) a
&gt;matrix_exponential x = shead $ drop 10 (matrix_exponential_stream x)



&gt;instance (Num a) =&gt; FiniteDimensional (Stream a) where
&gt;   finite (Matrix (Covector f)) = Pre (f (Covector shead))
&gt;                                      (fmap (\x -&gt; f $ Covector (shead . x)) tls)
&gt;    where tls = stail `Pre` (fmap (\x -&gt; x . stail) tls)

&gt;-- | Idea: 'limit' produces an exact value from a monotone sequence of
&gt;-- approximations
&gt;--
&gt;-- &lt;https://ncatlab.org/nlab/show/closure+operator&gt;
&gt;--
&gt;-- The Closure represents a sequentially closed set of elements
&gt;class Limiting a where
&gt;  data Closure a
&gt;  limit          :: Stream a -&gt; Closure a
&gt;  approximations :: Closure a -&gt; Stream a

&gt;class (Limiting a) =&gt; Closed a where
&gt;  accumulation_point :: Closure a -&gt; a

&gt;instance Limiting Integer where
&gt;   data Closure Integer = IntegerClosure { runIntegerClosure :: Stream Integer }
&gt;   limit = IntegerClosure
&gt;   approximations = runIntegerClosure

&gt;instance Limiting Rational where
&gt;   data Closure Rational = RationalClosure (Stream Rational)
&gt;   limit = RationalClosure
&gt;   approximations (RationalClosure s) = s

&gt;instance Limiting Double where
&gt;   data Closure Double = DoubleClosure (Stream Double)
&gt;   limit (Pre x xr) = DoubleClosure (Pre x xr)
&gt;   approximations (DoubleClosure x) = x

&gt;instance Closed Double where
&gt;   accumulation_point (DoubleClosure (Pre x (Pre y yr)))
&gt;     | abs (y - x) &lt;= 1 / (fromInteger $ (floatRadix 0) ^ (floatDigits 0 - 1)) = x
&gt;     | otherwise = accumulation_point (DoubleClosure yr)

&gt;instance Limiting () where
&gt;   data Closure () = TerminalClosure
&gt;   limit _ = TerminalClosure
&gt;   approximations TerminalClosure = Pre () (approximations TerminalClosure)

&gt;instance Closed () where
&gt;   accumulation_point TerminalClosure = ()

&gt;limiting_iso :: (TArrow.BiArrow arr, Limiting a) =&gt; arr (Stream a) (Closure a)
&gt;limiting_iso = limit TArrow.&lt;-&gt; approximations

&gt;vec_stream :: Stream a -&gt; Integer -&gt; a
&gt;vec_stream (Pre x xr) i = if i == 0 then x else vec_stream xr (pred i)

&gt;-- | mapping operation for closures.
&gt;-- Note we cannot make this a Functor instance due to constraint in the type.
&gt;cmap :: (Limiting a, Limiting b) =&gt; (a -&gt; b) -&gt; Closure a -&gt; Closure b
&gt;cmap f = limit . fmap f . approximations
&gt;
&gt;cliftA2 :: (Limiting a, Limiting b, Limiting c)
&gt;  =&gt; (a -&gt; b -&gt; c) -&gt; Closure a -&gt; Closure b -&gt; Closure c
&gt;cliftA2 f a b = limit $ liftA2 f (approximations a) (approximations b)
&gt;
&gt; 
&gt;-- | operation for producing a closure out of single element.
&gt;close :: (Limiting a) =&gt; a -&gt; Closure a
&gt;close x = limit $ constant x

&gt;closure_limit :: (Limiting a) =&gt; Stream (Closure a) -&gt; Closure a
&gt;closure_limit = stream_limit . limit . fmap approximations

&gt;-- | Monadic bind operation for closures,
&gt;-- again cannot be made instance of Monad.
&gt;(.&gt;&gt;=.) :: (Limiting a, Limiting b) =&gt; Closure a -&gt; (a -&gt; Closure b) -&gt; Closure b
&gt;x .&gt;&gt;=. f = limit $ approximations x &gt;&gt;= (approximations . f)

&gt;instance Foldable Stream where
&gt;   foldMap f (Pre x xr) = f x &lt;&gt; foldMap f xr

&gt;instance Traversable Stream where
&gt;   traverse f (Pre x xr) = Pre &lt;$&gt; f x &lt;*&gt; traverse f xr

&gt;instance (Limiting a) =&gt; Limiting (Stream a) where
&gt;   data Closure (Stream a) = SClosure {
&gt;     runSClosure :: Stream (Closure a),
&gt;     stream_limit :: Closure a }
&gt;   limit x = SClosure (fmap limit x) (limit $ stream_diagonal $ Matrix $ x)
&gt;   approximations = fmap approximations . runSClosure

&gt;instance (Show (Closure a)) =&gt; Show (Closure (Stream a)) where
&gt;   show (SClosure str l) = &quot;lim[&quot; ++ show (take 10 str) ++ &quot;...] = &quot; ++ show l

&gt;instance (Limiting a) =&gt; Closed (Stream a) where
&gt;   accumulation_point = approximations . stream_limit

&gt;instance (Applicative f, Traversable f,Applicative g, Traversable g, Limiting a) =&gt; Limiting ((f :*: g) a) where
&gt;   data Closure ((f :*: g) a) = MatrixClosure { runMatrixClosure :: (f :*: g) (Closure a) }
&gt;   limit z@(Pre x xr) = MatrixClosure $ fmap limit $ sequenceA z
&gt;   approximations = sequenceA . fmap approximations . runMatrixClosure

&gt;instance (Closed a, Applicative f, Applicative g, Traversable f, Traversable g) =&gt; Closed ((f :*: g) a) where
&gt;   accumulation_point (MatrixClosure m) = fmap accumulation_point m

&gt;-- | https://en.wikipedia.org/wiki/Power_iteration
&gt;eigenvector_by_power_iteration ::
&gt;   (Fractional (Matrix.Scalar (m a)),
&gt;    Matrix.NormedSpace (m a),
&gt;    Matrix.LinearTransform m m a)
&gt;   =&gt; (m :*: m) a -&gt; m a -&gt; Stream (m a)
&gt;eigenvector_by_power_iteration a b = iterate_stream (\b' -&gt; let m = a Matrix.&lt;&lt;*&gt; b' in (1 / Matrix.norm m) Matrix.%* m) b



&gt;stream_distance_count :: (Eq a) =&gt; Stream a -&gt; Stream a -&gt; Integer
&gt;stream_distance_count (Pre x xr) (Pre y yr) 
&gt;         | not (x == y) = 0
&gt;         | otherwise = succ $ stream_distance_count xr yr

&gt;stream_distance :: (Eq a) =&gt; Stream a -&gt; Stream a -&gt; Rational
&gt;stream_distance x y = 1 % (2 ^ stream_distance_count x y)

&gt;instance Limiting (IO ()) where
&gt;  data Closure (IO ()) = IOClosure { runIOClosure :: IO () }
&gt;  limit (Pre x xr) = IOClosure $ x &gt;&gt; runIOClosure (limit xr)
&gt;  approximations x = Pre (runIOClosure x) $ fmap (runIOClosure x &gt;&gt;) $ approximations x

&gt;instance (Monad m) =&gt; Limiting (Kleisli m a a) where
&gt;  data Closure (Kleisli m a a) = KleisliClosure { runKleisliClosure :: Kleisli m a a }
&gt;  limit (Pre x xr) = KleisliClosure $ (runKleisliClosure $ limit xr) C.. x
&gt;  approximations x = Pre (runKleisliClosure x) $ fmap (C.. runKleisliClosure x)$ approximations x

&gt;instance Nondeterministic.Nondeterministic Stream where
&gt;   guess = cycle

&gt;-- | Show instance displays every element of the stream, the output is infinite
&gt;instance (Show x) =&gt; Show (Stream x) where
&gt;  showsPrec i (Pre x xr) = shows x . showChar ',' . showsPrec i xr

   show (Pre x xr) = show x ++ &quot;,&quot; ++ show xr

&gt;-- | pretty printing displays 15 element prefix of the stream.
&gt;instance (PpShow x) =&gt; PpShow (Stream x) where
&gt;   pp z = pp_list (take 15 z)

&gt;instance PpShowF Stream where
&gt;   ppf z = pp_list (take 15 z)

&gt;instance PpShowVerticalF Stream where
&gt;   ppf_vertical z = vcat $ take 15 $ fmap pp z

&gt;instance Functor Stream where
&gt;   fmap f ~(Pre x xr) = Pre (f x) $ fmap f xr

&gt;-- | monoid instance for streams generated by monoid instance of the elements.
&gt;instance (Monoid a) =&gt; Monoid (Stream a) where
&gt;  mempty = pure mempty
&gt;  mappend = liftA2 mappend

&gt;instance (Semigroup a) =&gt; Semigroup (Stream a) where
&gt;   (&lt;&gt;) = liftA2 (&lt;&gt;)

instance (Num a) =&gt; Matrix.VectorSpace ((Stream :*: Stream) a) where
  type Scalar ((Stream :*: Stream) a) = a
  vzero = Matrix $ constant (constant 0)
  vnegate (Matrix x) = Matrix $ fmap (fmap negate) x
  v %* (Matrix x) = Matrix $ fmap (fmap (v *)) x
  (Matrix x) %+ (Matrix y) = Matrix $ liftA2 (liftA2 (+)) x y 

&gt;-- | square matrix implementation for streams.
&gt;instance (Num a) =&gt; Matrix.SquareMatrix Stream a where
&gt;  identity = stream_matrix (constant 1) $ codiag
&gt;     where codiag = (zero,zero) `Pre` codiag
&gt;  diagonal = stream_diagonal
&gt;  diagonal_matrix = stream_diagonal_matrix

&gt;-- | stream_diagonal is the &quot;depth-first&quot; traversal over two-dimensional streams,
&gt;-- where the choice always goes to diagonal elements.
&gt;--
&gt;-- prop&gt; stream_diagonal (matrix f x y) == liftA2 f x y
&gt;stream_diagonal :: (Stream :*: Stream) a -&gt; Stream a
&gt;stream_diagonal ~(Matrix ~(Pre ~(Pre x _) dr))
&gt;   = Pre x $ stream_diagonal $ Matrix $ fmap stail dr
  
&gt;instance (Matrix.ConjugateSymmetric a, Num a, Closed a)
&gt;     =&gt; Matrix.InnerProductSpace (Stream a) where
&gt;  x %. y = ssum $ do { (xa,ya) &lt;- x &lt;&amp;&gt; y ; return (xa*conj ya) }

&gt;instance (Closed a, Matrix.ConjugateSymmetric a, Floating a)
&gt;    =&gt; Matrix.NormedSpace (Stream a) where
&gt;  norm x = sqrt (x Matrix.%. x)

&gt;instance (Closed a, Num a) =&gt; Matrix.LinearTransform Stream Stream a where
&gt;  s &lt;*&gt;&gt; m = fmap (ssum . liftA2 (*) s) $ cells m
&gt;  m &lt;&lt;*&gt; s = fmap (ssum . liftA2 (*) s) $ cells $ transpose m

&gt;instance Matrix.Transposable Stream Stream where
&gt;  transpose x = stream_matrix (stream_diagonal x)
&gt;                              (fmap swap $ codiagonal_substreams $ codiagonal x)
&gt;    where swap (x,y) = (y,x)

&gt;instance (Num a) =&gt; Matrix.VectorSpace (Stream a) where
&gt;   type Scalar (Stream a) = a
&gt;   vzero = pure 0
&gt;   vnegate = liftA negate
&gt;   x %+ y = liftA2 (+) x y
&gt;   x %* s = liftA (x *) s


&gt;instance (Matrix.ConjugateSymmetric a) =&gt; Matrix.ConjugateSymmetric (Stream a) where
&gt;   conj (Pre x xr) = Pre (Matrix.conj x) (Matrix.conj xr)

&gt;-- | According to &lt;http://patternsinfp.wordpress.com/2010/12/31/stream-monad/&gt;, the diagonal
&gt;-- is the join of the stream monad.
&gt;instance Monad Stream where
&gt;   return = constant
&gt;   m &gt;&gt;= f = stream_diagonal (Matrix (fmap f m))
&gt;   fail str = Pre (error (&quot;Stream.fail:&quot; ++ str)) (fail str)

&gt;-- | sum of a stream elements.
&gt;ssum :: (Closed a, Num a) =&gt; Stream a -&gt; a
&gt;ssum = accumulation_point . limit . sum_stream

&gt;increasing_substream :: (Ord a) =&gt; Stream a -&gt; Stream a
&gt;increasing_substream (Pre x xr) = Pre x res
&gt;  where res = increasing_substream (dropWhile (&lt; x) xr)

&gt;sub_member :: (Ord a) =&gt; Stream a -&gt; a -&gt; Bool
&gt;sub_member s x = prim_member (increasing_substream s) x
&gt;   where prim_member (Pre x xr) y = case compare x y of
&gt;              EQ -&gt; True
&gt;              GT -&gt; False
&gt;              LT -&gt; prim_member xr y            

&gt;-- | bind diagonal element and horizontal and vertical strip
&gt;bind_matrix :: (Stream :*: Stream) a -&gt; (a -&gt; Stream a -&gt; Stream a -&gt; Stream b)
&gt;            -&gt; Stream b 
&gt;bind_matrix f h = do 
&gt;                     d &lt;- stream_diagonal f
&gt;                     (x,y) &lt;- stream_codiagonal f                       
&gt;                     h d x y

&gt;-- | stream matrix with a specified diagonal, other elements are zero.
&gt;stream_as_diagonal :: (Num a) =&gt; Stream a -&gt; (Stream :*: Stream) a
&gt;stream_as_diagonal x = stream_matrix x (return (zero,zero))

&gt;-- | adding a row to a matrix.
&gt;add_row :: f a -&gt; (Stream :*: f) a -&gt; (Stream :*: f) a
&gt;add_row x = Matrix . Pre x . cells

&gt;remove_row :: (Stream :*: f) a -&gt; (Stream :*: f) a
&gt;remove_row = Matrix . stail . cells

&gt;-- | adding a column to a matrix.
&gt;add_column :: (Applicative f) =&gt; f a -&gt; (f :*: Stream) a -&gt; (f :*: Stream) a
&gt;add_column x = Matrix . liftA2 Pre x . cells

&gt;remove_column :: (Functor f) =&gt; (f :*: Stream) a -&gt; (f :*: Stream) a
&gt;remove_column = Matrix . fmap stail . cells

&gt;join3 :: (Stream :*: Stream) a -&gt; Stream (a,a,a)
&gt;join3 m = m `bind_matrix` \x y z -&gt; do
&gt;              (y',z') &lt;- y &lt;&amp;&gt; z
&gt;              return (x,y',z')

&gt;instance Comonad Stream where
&gt;   extract = shead
&gt;   duplicate = cells . tails
&gt;   extend f z@(Pre _ xr) = Pre (f z) (extend f xr)

&gt;instance CircularComonad Stream where
&gt;   rotate = stail

&gt;instance InfiniteComonad Stream where
&gt;   pre = Pre

&gt;tails :: Stream a -&gt; (Stream :*: Stream) a
&gt;tails xs = Matrix $ Pre xs (cells $ tails (stail xs))

&gt;skippers :: Stream a -&gt; (Stream :*: Stream) a
&gt;skippers xs = Matrix $ Pre xs (cells $ skippers (skip_even xs))

&gt;-- | folds over streams
&gt;instance Visitor (Stream a) where
&gt;   data Fold (Stream a) b = forall c. StreamFold (a -&gt; c -&gt; b) (Fold (Stream a) c)
&gt;   visit (StreamFold f y) ~(Pre x xr) = f x (visit y xr)

&gt;-- | unfold for streams
&gt;instance (Builder a) =&gt; Builder (Stream a) where
&gt;   data Unfold (Stream a) b = StreamUnfold (Unfold a b) (Unfold (Stream a) b)
&gt;   build z'@(StreamUnfold e f) x = Pre (build e x) (build f x)

&gt;-- | The instance of Eq is kind of bogus, because equality for streams is
&gt;-- only semidecidable. So this implementation can produce False in finite
&gt;-- time, but True answer cannot be produced in finite time.
&gt;instance (Eq a) =&gt; Eq (Stream a) where
&gt;  (Pre x xr) == (Pre y yr) = x == y &amp;&amp; xr == yr

&gt;-- | Interpretation of a stream as a polynomial (its generating function)
&gt;-- Good exposition exists in http://en.wikipedia.org/wiki/Formal_power_series
&gt;--
&gt;-- the (*) operation is specific to generating function interpretation.
&gt;-- convolution/Cauchy product
&gt;--
&gt;-- prop&gt; (x * y)_k == sum [x_i * y_j | i+j==k]
&gt;-- 
&gt;instance (Num a) =&gt; Num (Stream a) where
&gt;   (+) = liftA2 (+)
&gt;   (-) = liftA2 (-)
&gt;   negate = liftA negate
&gt;   abs = liftA abs
&gt;   signum = liftA signum
&gt;   x * y = fmap sum_seq $ codiagonals_seq $ matrix (*) x y
&gt;   fromInteger i = Pre (fromInteger i) zero

&gt;sum_seq :: (Num a) =&gt; Seq a -&gt; a
&gt;sum_seq = foldr (+) 0

&gt;instance (Num a, Closed a, ConjugateSymmetric a) =&gt; Num ((Stream :*: Stream) a) where
&gt;   (+) = liftA2 (+)
&gt;   (-) = liftA2 (-)
&gt;   negate = liftA negate
&gt;   abs = liftA abs
&gt;   signum = liftA signum
&gt;   x * y = x %**% y
&gt;   fromInteger i = diagonal_matrix (fromInteger i)

&gt;stream_powers :: (Num a) =&gt; Stream a -&gt; (Stream :*: Stream) a
&gt;stream_powers f = Matrix $ Pre 1 $ fmap (f *) $ cells $ stream_powers f

&gt;-- | &lt;https://en.wikipedia.org/wiki/Formal_power_series&gt;
&gt;-- 
&gt;-- Note that identity of composition is 'z'.
&gt;compose :: (Num a, Eq a) =&gt; Stream a -&gt; Stream a -&gt; Stream a
&gt;compose g f@(Pre 0 _) = fmap sum $ liftA2 take nonzero_naturals
&gt;                                 $ cells $ Matrix.transpose $ Matrix
&gt;                                 $ fmap (liftA2 (*) g) (cells $ stream_powers f)
&gt;compose _ _ = error &quot;Stream must begin with zero to be pre-composed&quot;

&gt;matrix_convolution :: (Functor g,
&gt;                       Matrix.Transposable h f,
&gt;                       Matrix.InnerProductSpace (h a),
&gt;                       Matrix.VectorSpace ((g :*: f) (Matrix.Scalar (h a))))
&gt;                       =&gt; Stream ((g :*: h) a)
&gt;                       -&gt; Stream ((h :*: f) a)
&gt;                       -&gt; Stream ((g :*: f) (Matrix.Scalar (h a)))
&gt;matrix_convolution x y = fmap Matrix.vsum $ codiagonals_seq $ matrix (Matrix.%*%) x y

&gt;and_convolution :: Stream Bool -&gt; Stream Bool -&gt; Stream Bool
&gt;and_convolution x y = fmap or $ codiagonals_seq $ matrix (&amp;&amp;) x y

&gt;min_convolution :: (Num a, Ord a) =&gt; Stream a -&gt; Stream a -&gt; Stream a
&gt;min_convolution x y = fmap (foldr max 0) $ codiagonals_seq $ matrix min x y

&gt;and_stream :: Stream Bool -&gt; Stream Bool -&gt; Stream Bool
&gt;and_stream x y = do { b &lt;- x ; c &lt;- y ; return (b &amp;&amp; c) }

&gt;or_stream :: Stream Bool -&gt; Stream Bool -&gt; Stream Bool
&gt;or_stream x y = do { b &lt;- x ; c &lt;- y ; return (b || c) }

&gt;fromNum :: (Num a) =&gt; a -&gt; Stream a
&gt;fromNum i = Pre i zero

&gt;cycleQueueBy :: (a -&gt; b -&gt; b) -&gt; Queue a -&gt; b
&gt;cycleQueueBy f q = case Q.dequeue q of
&gt;                     (Just (v,q')) -&gt; f v (cycleQueueBy f $ Q.enqueue v q')
&gt;                     Nothing -&gt; error &quot;Cannot cycle empty queue&quot;

&gt;cycleQueue :: Queue a -&gt; Stream a
&gt;cycleQueue = cycleQueueBy Pre

&gt;convolve_with :: ([a] -&gt; b) -&gt; (c -&gt; d -&gt; a) -&gt; Stream c -&gt; Stream d -&gt; Stream b
&gt;convolve_with f g x y = fmap f $ codiagonals $ matrix g x y

&gt;convolve_with_seq :: (Seq a -&gt; b) -&gt; (c -&gt; d -&gt; a) -&gt; Stream c -&gt; Stream d -&gt; Stream b
&gt;convolve_with_seq f g x y = fmap f $ codiagonals_seq $ matrix g x y

&gt;data StreamIndex a = StreamIndex { sindex_position :: Integer, sindex_element :: a }

&gt;instance Comonad StreamIndex where
&gt;   extract (StreamIndex _ x) = x
&gt;   duplicate (StreamIndex i x) = StreamIndex i (StreamIndex i x)
&gt;   extend f z@(StreamIndex i _) = StreamIndex i (f z)

&gt;instance Functor StreamIndex where
&gt;   fmap f (StreamIndex i x) = StreamIndex i (f x)

&gt;instance Adjunction StreamIndex Stream where
&gt;   unit t = liftA2 StreamIndex naturals (constant t)
&gt;   counit (StreamIndex i s) = i `streamindex` s

&gt;instance (Show a) =&gt; Show (StreamIndex a) where
&gt;   show (StreamIndex i x) = show i ++ &quot;:&quot; ++ show x

&gt;-- | this instance of Ord goes to infinite loop if the compared streams are
&gt;-- equal.
&gt;instance (Ord a) =&gt; Ord (Stream a) where
&gt;   compare (Pre x xr) (Pre y yr) = case compare x y of
&gt;                                     LT -&gt; LT
&gt;                                     GT -&gt; GT
&gt;                                     EQ -&gt; compare xr yr

&gt;instance (MedianAlgebra a) =&gt; MedianAlgebra (Stream a) where
&gt;   med = liftA3 med

&gt;instance (Enum a, Num a) =&gt; Enum (Stream a) where
&gt;   succ (Pre x xr) = Pre (succ x) xr
&gt;   pred (Pre x xr) = Pre (pred x) xr
&gt;   toEnum i = Pre (toEnum i) zero
&gt;   fromEnum (Pre x _) = fromEnum x
&gt;   enumFrom p = p : fmap succ (enumFrom p)
&gt;   enumFromThen p q = p : fmap (+ diff) (enumFromThen p q)
&gt;     where diff = q - p
&gt;   enumFromTo p q = unzipList $ liftA2 enumFromTo p q

&gt; --   enumFromThen p q = p : fmap (+ diff) (enumFromThen p q)
&gt; --     where diff = fmap P.subtract q p
&gt;   -- TODO: missing functions

&gt;instance (Num a, Ord a, Real a) =&gt; Real (Stream a) where
&gt;   toRational (Pre x _) = toRational x

&gt;-- | Integral instance is based on interpretation of
&gt;-- a stream as generating function.
&gt;instance (Integral a) =&gt; Integral (Stream a) where
&gt;   quot x y = x * quotient_invert y
&gt;   div x y = x * inversion y
&gt;   rem x y = x - ((x * inversion y)*y)
&gt;   quotRem x y = (x*quotient_invert y, x - ((x*quotient_invert y)*y))
&gt;   toInteger = toInteger . shead

&gt;-- | Fractional instance is based on interpretation of
&gt;-- a stream as generating function.
&gt;instance (Fractional a) =&gt; Fractional (Stream a) where
&gt;   recip = reciprocal
&gt;   fromRational r = fromInteger (numerator r) * reciprocal (fromInteger (denominator r))


&gt;-- | fold over streams
&gt;streamfold :: (a -&gt; b -&gt; b) -&gt; Fold (Stream a) b
&gt;streamfold f = let x = StreamFold f x in x

&gt;fold_codiagonals :: ([a] -&gt; b -&gt; b) -&gt; (Stream :*: Stream) a -&gt; b
&gt;fold_codiagonals f = visit (streamfold f) . codiagonals

&gt;streamfold2 :: (a -&gt; c -&gt; b) -&gt; (a -&gt; b -&gt; c) -&gt; Fold (Stream a) b
&gt;streamfold2 f g = let x = StreamFold f (StreamFold g x) in x

&gt;streamfold_lst :: [a -&gt; b -&gt; b] -&gt; Fold (Stream a) b
&gt;streamfold_lst lst = let x = foldr StreamFold x lst in x

&gt;streamfold_stream :: Stream (a -&gt; b -&gt; b) -&gt; Fold (Stream a) b
&gt;streamfold_stream (Pre x xr) = StreamFold x (streamfold_stream xr)

&gt;rotate_prefix :: Integer -&gt; Stream a -&gt; Stream a
&gt;rotate_prefix k (Pre c cr) = (take k cr ++ [c]) `prefix` drop k cr

&gt;threeNplusOne :: Integer -&gt; Integer
&gt;threeNplusOne n | n == 1 = 1
&gt;                | odd n  = 3 * n + 1
&gt;                | otherwise = n `div` 2

&gt;toNatSeq :: Stream a -&gt; Rec Maybe -&gt; a
&gt;toNatSeq (Pre x _) (In Nothing) = x
&gt;toNatSeq (Pre _ xr) (In (Just y)) = toNatSeq xr y

&gt;fromIntegerSeq :: (Integer -&gt; a) -&gt; Stream a
&gt;fromIntegerSeq f = fmap f naturals

&gt;-- | prop&gt; sumSeq f i == Sum[n=i..Infinity](f(n))
&gt;sumSeq :: (Num b, Num a, Ord a) =&gt; (a -&gt; b) -&gt; a -&gt; Stream b
&gt;sumSeq f i = sum_stream $ fmap f $ naturals_starting_from i

&gt;boolValue :: (Num a) =&gt; Bool -&gt; a
&gt;boolValue b = if b then 1 else 0

&gt;fromBoolSeq :: (Num a) =&gt; (Integer -&gt; Bool) -&gt; Stream a
&gt;fromBoolSeq f = fromIntegerSeq (boolValue . f)

&gt;streamIndexFold :: Fold (Stream a) (Integer -&gt; a)
&gt;streamIndexFold = streamfold (\ x r i -&gt; if i == 0 then x else r (i-1))

&gt;streamindex :: Integer -&gt; Stream a -&gt; a
&gt;streamindex = flip (visit streamIndexFold)

&gt;streamindex2 :: (Integer,Integer) -&gt; (Stream :*: Stream) a -&gt; a
&gt;streamindex2 (a,b) m = m &lt;!&gt; (streamindex a, streamindex b)
  
&gt;map_indices :: (Integer -&gt; Integer) -&gt; Stream a -&gt; Stream a
&gt;map_indices f s = fromIntegerSeq ((`streamindex` s) . f)

&gt;-- | stream consisting of the same element repeated.
&gt;constant :: a -&gt; Stream a
&gt;constant x = Pre x (constant x)

&gt;limit_fold :: (a -&gt; a -&gt; a) -&gt; Fold (Stream a) (Integer -&gt; a)
&gt;limit_fold f = streamfold (\ x r i -&gt; if i &gt; 0 then f x (r (i-1)) else x)

&gt;limit_fold_gen :: (a -&gt; b -&gt; b) -&gt; (a -&gt; b) -&gt; Fold (Stream a) (Integer -&gt; b)
&gt;limit_fold_gen f g = streamfold (\ x r i -&gt; if i &gt; 0 then f x (r (i-1)) else g x)

&gt;iterate_stream :: (a -&gt; a) -&gt; a -&gt; Stream a
&gt;iterate_stream f x = Pre x (iterate_stream f (f x))

&gt;stream_differences :: (Num a) =&gt; Stream a -&gt; Stream a
&gt;stream_differences (Pre x z@(Pre y _)) = 
&gt;        Pre (y - x) $ stream_differences z

&gt;stream_quotients :: (Fractional a) =&gt; Stream a -&gt; Stream a
&gt;stream_quotients (Pre x z@(Pre y _)) = Pre (y/x) $ stream_quotients z

&gt;fixpoint :: (Limiting a) =&gt; (a -&gt; a) -&gt; a -&gt; Closure a
&gt;fixpoint f x = limit $ iterate_stream f x

&gt;matrix_inverse a = iterate_stream (\xk -&gt; (fmap (2 *) xk) %- xk %**% a %**% xk)

&gt;stream_min :: (Ord a) =&gt; Fold (Stream a) (Integer -&gt; a)
&gt;stream_min = limit_fold min
&gt;
&gt;stream_max :: (Ord a) =&gt; Fold (Stream a) (Integer -&gt; a)
&gt;stream_max = limit_fold max
&gt;
&gt;liftStream2 :: (a -&gt; a -&gt; a) -&gt; Stream a -&gt; Stream a
&gt;liftStream2 f = fromIntegerSeq . visit (limit_fold f)

&gt;min_stream :: (Ord a) =&gt; Stream a -&gt; Stream a
&gt;min_stream = liftStream2 min

&gt;max_stream :: (Ord a) =&gt; Stream a -&gt; Stream a
&gt;max_stream = liftStream2 max

&gt;stream_product :: (Num a) =&gt; Fold (Stream a) (Integer -&gt; a)
&gt;stream_product = limit_fold (*)

&gt;stream_sum :: (Num a) =&gt; Fold (Stream a) (Integer -&gt; a)
&gt;stream_sum = limit_fold (+)

&gt;-- | product_stream produce from a stream @[a0,a1,a2,...]@ a stream
&gt;-- @[a0,a0*a1,a0*a1*a2,a0*a1*a2*a3,...]@
&gt;product_stream :: (Num a) =&gt; Stream a -&gt; Stream a
&gt;product_stream = liftStream2 (*)

&gt;-- | sum_stream will produce from a stream @[a0,a1,a2,...]@ a stream
&gt;-- @[a0,a0+a1,a0+a1+a2,...]@.

&gt;sum_stream :: (Num a) =&gt; Stream a -&gt; Stream a
&gt;sum_stream = liftStream2 (+)

&gt;sum_stream_integral :: (Integral a) =&gt; Stream a -&gt; Stream a
&gt;sum_stream_integral s = s `div` (1 - z)

&gt;sum_stream_fractional :: (Fractional a) =&gt; Stream a -&gt; Stream a
&gt;sum_stream_fractional s = s / (1 - z)

&gt;-- | if 'f' in cobind is a fixed-point free function, then this will find a
&gt;-- stream that is not an element of any of the streams.

&gt;cobind :: (a -&gt; b) -&gt; (Stream :*: Stream) a -&gt; Stream b
&gt;cobind f = fmap f . stream_diagonal

&gt;indexed_lookup :: Stream Integer -&gt; Stream a -&gt; Stream a
&gt;indexed_lookup (Pre i x) s = Pre y (indexed_lookup x yr)
&gt;   where (Pre y yr) = drop i s 

&gt;universal :: (Stream :*: Stream) Bool -&gt; Stream Bool
&gt;universal = fmap and . codiagonals_seq

&gt;existential :: (Stream :*: Stream) Bool -&gt; Stream Bool
&gt;existential = fmap or . codiagonals_seq

&gt;topleft :: (Stream :*: Stream) a -&gt; a
&gt;topleft = shead . stream_diagonal

&gt;-- | Everything but a diagonal

&gt;stream_codiagonal :: (Stream :*: Stream) a -&gt; Stream (Stream a, Stream a)
&gt;stream_codiagonal ~(Matrix ~(Pre ~(Pre _ x) yr)) = Pre (x,fmap shead yr)
&gt;               (stream_codiagonal $ Matrix $ fmap stail yr)

&gt;instance CodiagonalMatrix Stream a where
&gt;   data Codiagonal Stream a = CodiagonalStream { codiagonal_substreams :: Stream (Stream a, Stream a) }
&gt;   type (Stream \\ a) = Stream a
&gt;   codiagonal = CodiagonalStream . stream_codiagonal
&gt;   diag |\| (CodiagonalStream codiag) = stream_matrix diag codiag
&gt;   down_project (CodiagonalStream (Pre (x,_) _)) = x
&gt;   right_project (CodiagonalStream (Pre (_,y) _)) = y

&gt;zero_codiagonal :: (Num a) =&gt; Codiagonal Stream a
&gt;zero_codiagonal = CodiagonalStream $ constant (constant 0, constant 0)

&gt;stream_diagonal_matrix :: (Num a) =&gt; Stream a -&gt; (Stream :*: Stream) a
&gt;stream_diagonal_matrix m = m |\| zero_codiagonal

&gt;-- | stream_matrix creates matrix from a diagonal and a codiagonal

&gt;stream_matrix :: Stream a -&gt; Stream (Stream a, Stream a) -&gt; (Stream :*: Stream) a
&gt;stream_matrix (Pre x xr) (Pre (y,yh) yr) = Matrix $ Pre (Pre x y)
&gt;                             (liftA2 Pre yh (cells (stream_matrix xr yr)))

&gt;prefix_stream_matrix :: Stream a -&gt; (Stream a, Stream a) -&gt; (Stream :*: Stream) a -&gt; (Stream :*: Stream) a
&gt;prefix_stream_matrix (Pre x xr) (row,col) (Matrix m) = Matrix $ 
&gt;       Pre (Pre x row) $ liftA2 Pre col m

&gt;pseudo_codiagonal :: (Stream :*: Stream) a -&gt; Codiagonal Stream a
&gt;pseudo_codiagonal (Matrix (Pre (Pre _ x)
&gt;                       (Pre y yr))) = CodiagonalStream $
&gt;                             Pre (x,y) (codiagonal_substreams $ pseudo_codiagonal $ Matrix yr)

&gt;pseudo_matrix :: Stream a -&gt; Stream (Stream a, Stream a) -&gt; (Stream :*: Stream) a
&gt;pseudo_matrix (Pre a ar) (Pre (x,y) yr) = Matrix $ Pre (Pre a x) (Pre y (cells $ pseudo_matrix ar yr))

&gt;map_matrix :: (a -&gt; b) 
&gt;           -&gt; ((Stream a,Stream a) -&gt; (Stream b, Stream b))
&gt;           -&gt; (Stream :*: Stream) a -&gt; (Stream :*: Stream) b
&gt;map_matrix f g s = stream_matrix (fmap f y) (fmap g x)
&gt;   where x = stream_codiagonal s
&gt;         y = stream_diagonal s

&gt;map_diagonal :: (a -&gt; a) -&gt; (Stream :*: Stream) a -&gt; (Stream :*: Stream) a
&gt;map_diagonal f = map_matrix f id

&gt;joinWith :: (a -&gt; b -&gt; c) -&gt; Stream a -&gt; Stream b -&gt; Stream c
&gt;joinWith f x y = cojoin (matrix f x y)

&gt;instance Applicative Stream where
&gt;   pure = constant
&gt;   (Pre f fr) &lt;*&gt; (Pre b br) = Pre (f b) (fr &lt;*&gt; br)

&gt;instance Indexable Stream where
&gt;   diagonal_projections = Pre shead $ fmap (\a -&gt; a . stail) diagonal_projections
&gt;   indexable_indices = fmap fromIntegral naturals

&gt;zipList :: ([a] -&gt; b) -&gt; [Stream a] -&gt; Stream b
&gt;zipList f lst = Pre (f (map shead lst)) (zipList f (map stail lst))

&gt;sequence :: [Stream a] -&gt; Stream [a]
&gt;sequence = zipList id

&gt;unzipList :: Stream [a] -&gt; [Stream a]
&gt;unzipList z = fmaphead z : unzipList (fmaptail z)
&gt;  where fmaphead (Pre (c:_) xr) = Pre c (fmaphead xr)
&gt;        fmaphead (Pre []     xr) = fmaphead xr
&gt;        fmaptail (Pre (_:cr) xr) = Pre cr (fmaptail xr)
&gt;        fmaptail (Pre []     xr) = fmaptail xr
  
&gt;zipStream :: (Functor f) =&gt; (f b -&gt; a) -&gt; f (Stream b) -&gt; Stream a
&gt;zipStream f inp = Pre (f (fmap shead inp)) (zipStream f (fmap stail inp))

&gt;sequenceStream :: (Functor f) =&gt; f (Stream a) -&gt; Stream (f a)
&gt;sequenceStream = zipStream id

&gt;apply3 :: Stream (a -&gt; b -&gt; c) -&gt; Stream a -&gt; Stream b -&gt; Stream c
&gt;apply3 = liftA3 ($)

&gt;applyA :: (Arrow arr) =&gt; Stream (arr a b) -&gt; arr (Stream a) (Stream b)
&gt;applyA (Pre f fr) = proc (Pre y yr) -&gt; do
&gt;                      y' &lt;- f -&lt; y
&gt;                      yr' &lt;- applyA fr -&lt; yr
&gt;                      returnA -&lt; Pre y' yr'

&gt;dematrix :: (Stream :*: Stream) a
&gt;               -&gt; (a, (Stream a, Stream a), (Stream :*: Stream) a)
&gt;dematrix y = (d,zz,stream_matrix dr cr)
&gt;   where ~(Pre d  dr) = stream_diagonal y
&gt;         ~(Pre zz cr) = stream_codiagonal y

                      
codiagonals :: (Stream :*: Stream) a -&gt; Stream [a]
codiagonals q
   | (d,~(Pre x xr, Pre y yr),m) &lt;- dematrix q = Pre [d] $ Pre [x,y] $ liftA3 f xr yr $ codiagonals m
    where f pre suf r = pre : (r ++ [suf])

This is faster than above commented version of codiagonals, because
the suffix computation on Seq is constant time rather than linear.

&gt;codiagonals_seq :: (Stream :*: Stream) a -&gt; Stream (Seq a)
&gt;codiagonals_seq q
&gt;   | ~(d,~(Pre x xr, Pre y yr),m) &lt;- dematrix q =
&gt;       Pre (Seq.singleton d) $
&gt;       Pre (Seq.singleton x Seq.|&gt; y) $
&gt;       liftA3 f xr yr $ codiagonals_seq m
&gt;    where f pre suf r = (pre Seq.&lt;| r) Seq.|&gt; suf


&gt;-- | The 'codiagonals' function will divide a two-dimensional
&gt;-- stream of streams (where elements are @e_(i,j)@ into a stream of
&gt;-- lists
&gt;-- 
&gt;--   @l_k@ where @l_k = [e_(i,j) | i &lt;- naturals, j &lt;- naturals, i+j == k]@
&gt;-- 
&gt;-- The indices in the streams are closely related to &quot;Cantor pairing
&gt;-- function&quot; (which is a bijection)
&gt;--
&gt;-- @
&gt;-- f :: (N,N) -&gt; N
&gt;-- f(x,y) = (x+y)(x+y+1)/2 + x
&gt;-- @
&gt;--  
&gt;-- Note that the list at each element of the resulting stream is of
&gt;-- finite (but increasing) size. The order in each list is such that the
&gt;-- diagonal elements are at the center of (the every second) list.
&gt;-- 
&gt;-- It is possible to think of this as &quot;breadth-first&quot; traversal
&gt;-- over two-dimensional streams.
&gt;--
&gt;-- @
&gt;--  d   x xr0 xr1  xr2 ..
&gt;--  y   d' x' xr0' xr1' ..
&gt;--  yr0 y'
&gt;--  yr1 yr0'
&gt;--  yr2 yr1'
&gt;--  ..
&gt;-- @
&gt;--
&gt;-- There is symmetry between primed and unprimed (e.g. d and d') towards
&gt;-- the diagonal.
&gt;-- 
&gt;-- The resulting lists would be: 
&gt;--  @[d], [x,y], [xr0,d',yr0], [xr1,x',y',yr1],...@

&gt;codiagonals :: (Stream :*: Stream) a -&gt; Stream [a]
&gt;codiagonals x = fmap Data.Foldable.toList $ codiagonals_seq x

&gt;data Transform2D a b = Transform2D {
&gt;   transform_diagonal   :: a -&gt; b,
&gt;   transform_commutator :: a -&gt; a -&gt; b,
&gt;   transform_symmetry :: a -&gt; b -&gt; a -&gt; b }

&gt;element2D :: a -&gt; a -&gt; Transform2D () a
&gt;element2D x y = Transform2D (\ () -&gt; x) (\ () () -&gt; y) (\ () m () -&gt; m)

&gt;commutatorSum2D :: (LieAlgebra a) =&gt; Transform2D a a
&gt;commutatorSum2D = Transform2D vnegate (%&lt;&gt;%) (\x y z -&gt; x %+ y %+ z)

&gt;transpose2D :: Transform2D a b -&gt; Transform2D a b
&gt;transpose2D (Transform2D f c s) = Transform2D f (flip c) $ \a m b -&gt; s b m a

&gt;compose2D :: Transform2D b c -&gt; Transform2D a b -&gt; Transform2D a c
&gt;compose2D (Transform2D d c s) (Transform2D d' c' s')
&gt;  = Transform2D (d . d')
&gt;                (\a b -&gt; c (c' a b) (c' b a))
&gt;                (\a m b -&gt; s (s' a (d' a) b) m (s' a (d' b) b))

&gt;codiagonalsWith :: Transform2D a b -&gt; (Stream :*: Stream) a -&gt; Stream b
&gt;codiagonalsWith z@(Transform2D diag pair thr) q = Pre (diag d) $ Pre (pair x y) $
&gt;             liftA3 thr xr (codiagonalsWith z m) yr 
&gt;    where (d,(Pre x xr, Pre y yr),m) = dematrix q

&gt;monoid2D :: (Monoid a) =&gt; (a -&gt; a -&gt; a -&gt; a) -&gt; Transform2D a a
&gt;monoid2D = Transform2D (const mempty) mappend

&gt;productSum2D :: (Num a) =&gt; Transform2D a a
&gt;productSum2D = Transform2D id (*) $ \a m b -&gt; a + m + b

&gt;set2D :: (Ord a) =&gt; Transform2D a (Set.Set a)
&gt;set2D = Transform2D Set.singleton (\a b -&gt; Set.insert b (Set.singleton a)) (\a s b -&gt; Set.insert a (Set.insert b s))

&gt;project2D :: (a -&gt; (a,a) -&gt; a -&gt; (a,a)) -&gt; Transform2D a (a,a)
&gt;project2D f = Transform2D (\a -&gt; (a,a)) (,) f

&gt;flattenList2D :: Transform2D [a] [a]
&gt;flattenList2D = Transform2D id (++) (\a b c -&gt; a ++ b ++ c)

&gt;list2D :: Transform2D a [a]
&gt;list2D = Transform2D (\a -&gt; [a]) (\a b -&gt; [a,b]) (\a m b -&gt; a : m ++ [b])

&gt;seq2D :: Transform2D a (Seq a)
&gt;seq2D = Transform2D (\a -&gt; Seq.singleton a) (\a b -&gt; Seq.singleton a |&gt; b)
&gt;                    (\a m b -&gt; a &lt;| (m |&gt; b))

&gt;-- | for uncodiagonals, the i'th list element of the input stream must have length 'i'.
&gt;-- 
&gt;-- @uncodiagonals ([a] \`Pre\` [b,c] \`Pre\` [d,e,f] ...)@
&gt;--  == @Pre (a \`Pre\` c \`Pre\` f ...) $
&gt;--     Pre (b \`Pre\` e \`Pre\` ...) $
&gt;--     Pre (d \`Pre\` ...  ) $
&gt;--     ...@
&gt;--
&gt;-- &lt;https://en.wikipedia.org/wiki/Formal_power_series&gt;                        
&gt;uncodiagonals :: Stream [a] -&gt; (Stream :*: Stream) a
&gt;uncodiagonals (Pre [d] (Pre [x,y] re)) = stream_matrix diag codiag
&gt; where codiaghead = (x `Pre` fmap head re,y `Pre` fmap last re)
&gt;       codiag = codiaghead `Pre` stream_codiagonal next
&gt;       diag = d `Pre` stream_diagonal next
&gt;       next = uncodiagonals $ fmap (\lst -&gt; P.take (length lst - 2) (tail lst)) re

&gt;takes :: Stream Integer -&gt; Stream a -&gt; Stream [a]
&gt;takes (Pre x xr) s = Pre (take x s) $ takes xr (drop x s)

&gt;split_dimension :: Stream a -&gt; (Stream :*: Stream) a
&gt;split_dimension = uncodiagonals . takes nonzero_naturals

&gt;split_planar :: Stream a -&gt; (Stream :*: Stream) a
&gt;split_planar = uncodiagonals . fmap (\lst -&gt; if odd (length lst) then lst else reverse lst) . takes nonzero_naturals

&gt;codiagonalsIso :: (TArrow.BiArrow arr) =&gt; arr ((Stream :*: Stream) a) (Stream [a])
&gt;codiagonalsIso = codiagonals TArrow.&lt;-&gt; uncodiagonals

&gt;-- | lower_triangle takes lower half of a two-dimensional stream split at diagonal.
&gt;lower_triangle :: (Stream :*: Stream) a -&gt; (Stream :*: Stream) a
&gt;lower_triangle = uncodiagonals . liftA2 take nonzero_naturals . cells

&gt;-- | upper_triangle takes upper half of a two-dimensional stream split at diagonal.
&gt;upper_triangle :: (Stream :*: Stream) a -&gt; (Stream :*: Stream) a
&gt;upper_triangle = lower_triangle . transpose

&gt;pairing_matrix :: (Fractional a) =&gt; (Stream :*: Stream) a
&gt;pairing_matrix = Matrix $ (z+z2)*(z+z2+1)/2+z

&gt;codiagonals3 :: (Stream :*: (Stream :*: Stream)) a -&gt; Stream [[a]]
&gt;codiagonals3 = codiagonals . Matrix . fmap codiagonals . cells

&gt;-- | concatenate a stream of lists to a stream of elements
&gt;concatenate :: Stream [a] -&gt; Stream a
&gt;concatenate (Pre [] xr) = concatenate xr
&gt;concatenate (Pre (c:cr) xr) = Pre c (concatenate (Pre cr xr))

&gt;diagonalize :: Stream [a] -&gt; Stream a
&gt;diagonalize (Pre [] xr) = diagonalize (fmap nice_tail xr)
&gt;diagonalize (Pre (c:_) xr) = Pre c (diagonalize (fmap nice_tail xr))

&gt;skip_even :: Stream a -&gt; Stream a
&gt;skip_even (Pre x (Pre _ yr)) = Pre x (skip_even yr)

&gt;nice_tail :: [a] -&gt; [a]
&gt;nice_tail [] = []
&gt;nice_tail ~(_:cr) = cr

&gt;diagonal_differences :: (a -&gt; b) -&gt; (Stream :*: Stream) a -&gt; Stream b
&gt;diagonal_differences neg = fmap neg . stream_diagonal

&gt;find_equal :: (Eq a) =&gt; Stream a -&gt; Stream a -&gt; a
&gt;find_equal (Pre x xr) (Pre y yr) | x == y = x
&gt;                                 | otherwise = find_equal xr yr

&gt;fixedpoint :: (Eq a) =&gt; (a -&gt; a) -&gt; (Stream :*: Stream) a -&gt; a
&gt;fixedpoint f s = find_equal diag (fmap f diag)
&gt;   where diag = stream_diagonal s

&gt;sum_join :: (Num a) =&gt; (Stream :*: Stream) a -&gt; Stream a
&gt;sum_join = fmap sum . codiagonals_seq
&gt;
&gt;sum_bind :: (Num b) =&gt; Stream a -&gt; (a -&gt; Stream b) -&gt; Stream b
&gt;sum_bind x f = sum_join $ Matrix $ fmap f x

&gt;-- | cojoin is &quot;better&quot; version of join for streams. cojoin does not
&gt;-- satisfy monad laws (Right identity and associativity do not hold.).
&gt;-- It eventually produces every element of the original two-dimensional
&gt;-- stream. It first produces all elements e_(i,j) where i+j=k and k
&gt;-- increasing.


&gt;cojoin :: (Stream :*: Stream) a -&gt; Stream a
&gt;cojoin = concatenate . codiagonals

&gt;-- |
&gt;-- &gt; naturals |*| naturals == (0,0),   [note sum=0]
&gt;-- &gt;                          (0,1),(1,0),  [note sum=1]
&gt;-- &gt;                          (0,2),(2,0),(1,1),  [note sum=2]
&gt;-- &gt;                          (0,3),(3,0),(1,2),(2,1),  [note sum=3]
&gt;-- &gt;                          (0,4),(4,0),(1,3),(3,1),(2,2),  [note sum=4]
&gt;-- &gt;                           ...
  
&gt;(|*|) :: Stream a -&gt; Stream b -&gt; Stream (a,b)
&gt;f |*| g = cojoin $ matrix (,) f g

&gt;-- | For a better &quot;bind&quot; operation, there exists (&gt;&gt;!=), which produces
&gt;-- the following result (note duplicates):
&gt;--
&gt;-- &gt;naturals &gt;&gt;!= \x -&gt; naturals &gt;&gt;!= \y -&gt; return (x,y)
&gt;-- &gt;== (0,0),
&gt;-- &gt;  (0,0),(1,0),
&gt;-- &gt;     (0,1),(1,0),(2,0),
&gt;-- &gt;  (0,0),(1,1),(2,0),(3,0),
&gt;-- &gt;    (0,1),(1,0),(2,1),(3,0),(4,0),
&gt;-- &gt;      (0,2),(1,1),(2,0),(3,1),(4,0),(5,0),
&gt;-- &gt;  (0,0),(1,2),(2,1),(3,0),(4,1),(5,0),(6,0),
&gt;-- &gt;    (0,1),(1,0),(2,2),(3,1),(4,0),(5,1),(6,0),(7,0),
&gt;-- &gt;      (0,2),(1,1),(2,0),(3,2),(4,1),(5,0),(6,1),(7,0),(8,0),
&gt;-- &gt;       (0,3),(1,2),(2,1),(3,0),(4,2),(5,1),(6,0),(7,1),(8,0),(9,0),
&gt;-- &gt;  ...

&gt;(&gt;&gt;!=) :: Stream a -&gt; (a -&gt; Stream b) -&gt; Stream b
&gt;m &gt;&gt;!= f = cojoin $ Matrix $ fmap f m

&gt;-- | The (&gt;!=) is like binding, but the results are packaged
&gt;-- to a finite list. Again note duplicates.
&gt;--
&gt;-- 
&gt;-- &gt;naturals &gt;!= \x -&gt; naturals &gt;!= \y -&gt; return (x,y)
&gt;-- &gt;== [[(0,0)]
&gt;-- &gt;  ],
&gt;-- &gt;  [[(0,0),(0,1)],
&gt;-- &gt;   [(1,0)]
&gt;-- &gt;  ],
&gt;-- &gt;  [[(0,0),(0,1),(0,2)],
&gt;-- &gt;   [(1,0),(1,1)],
&gt;-- &gt;   [(2,0)],
&gt;-- &gt;  ],
&gt;-- &gt;  [[(0,0),(0,1),(0,2),(0,3)],
&gt;-- &gt; [(1,0),(1,1),(1,2)],
&gt;-- &gt; [(2,0),(2,1)],
&gt;-- &gt; [(3,0)]
&gt;-- &gt;],
&gt;-- &gt;...
&gt;-- 

&gt;(&gt;!=) :: Stream a -&gt; (a -&gt; Stream b) -&gt; Stream [b]
&gt;m &gt;!= f = codiagonals $ Matrix $ fmap f m

&gt;integers :: (Num a) =&gt; Stream a
&gt;integers = interleave naturals (fmap negate nonzero_naturals)

&gt;-- | A stream of integers. This is specialized version of naturals for integers
&gt;integers_stream :: Stream Integer
&gt;integers_stream = naturals

&gt;-- | A stream of increasing numbers starting from 0
&gt;naturals :: (Num a) =&gt; Stream a
&gt;naturals = Pre 0 nonzero_naturals

&gt;-- | A stream of increasing numbers starting from a given number.
&gt;naturals_starting_from :: (Num a, Ord a) =&gt; a -&gt; Stream a
&gt;naturals_starting_from i = dropWhile (&lt; i) naturals

&gt;-- | A stream of increasing numbers starting from 1
&gt;nonzero_naturals :: (Num a) =&gt; Stream a
&gt;nonzero_naturals = fmap (+ 1) naturals

&gt;integral_nonzero_naturals :: (Integral a) =&gt; Stream a
&gt;integral_nonzero_naturals = 1 `div` (1 - 2*z + z*z)

&gt;integral_naturals :: (Integral a) =&gt; Stream a
&gt;integral_naturals = Pre 0 integral_nonzero_naturals

&gt;-- | This is the variable used in generating functions.  Note that in
&gt;-- multidimensional streams, this is the variable associated with the
&gt;-- largest dimension.

&gt;z :: (Num a) =&gt; Stream a
&gt;z = Pre 0 (Pre 1 0)

&gt;-- | The variable associated with second largest dimension:

&gt;z2 :: (Num a) =&gt; Stream (Stream a)
&gt;z2 = Pre z 0

&gt;z2_matrix :: (Num a) =&gt; (Stream :*: Stream) a
&gt;z2_matrix = Matrix z2

&gt;-- | variable associated with third largest dimension

&gt;z3 :: (Num a) =&gt; Stream (Stream (Stream a))
&gt;z3 = Pre z2 0

&gt;z3_matrix :: (Num a) =&gt; (Stream :*: Stream :*: Stream) a
&gt;z3_matrix = Matrix (Matrix z3)

&gt;log_stream :: (Num a) =&gt; (Stream :*: Stream) a
&gt;log_stream = stream_powers (z-1)

&gt;stream_logarithm :: (Fractional a) =&gt; Stream a -&gt; Stream a
&gt;stream_logarithm s = liftA2 (/) s factorial

&gt;stream_log :: (Integral a) =&gt; Stream a -&gt; Stream a
&gt;stream_log s = liftA2 div s factorial

&gt;-- | For a stream of terms @a=[a0,a1,a2,...]@, and @x=[x0,x1,x2,...]@,
&gt;-- 'approximate_sums a x' computes
&gt;-- @\\n -&gt; Sum[i=0..n]{a_i*x_i^i}@, where n is the index to the result stream.

&gt;approximate_sums :: (Fractional a) =&gt; Stream a -&gt; Stream a -&gt; Stream a
&gt;approximate_sums gen x = diagonal $ Matrix $ fmap sum_stream $ cells $ matrix (*) gen (index_powers x)

&gt;exponential_stream :: (Fractional a) =&gt; Stream a
&gt;exponential_stream = Pre 1 $ fmap (1/) factorial

&gt;exponential :: (Eq a, Fractional a) =&gt; Stream a -&gt; Stream a
&gt;exponential = compose exponential_stream

&gt;log_generating_function :: (Fractional a) =&gt; Stream a
&gt;log_generating_function = negate $ fmap (1/) nonzero_naturals

&gt;-- | &lt;https://en.wikipedia.org/wiki/Trigonometric_functions&gt;

&gt;cos_stream :: (Fractional a) =&gt; Stream a -&gt; Stream a
&gt;cos_stream x = uninterleave_index 1 $ stail $ approximate_sums cos_generating_function x

&gt;-- | &lt;https://en.wikipedia.org/wiki/Trigonometric_functions&gt;

&gt;sin_stream :: (Fractional a) =&gt; Stream a -&gt; Stream a
&gt;sin_stream x = uninterleave_index 1 $ approximate_sums sin_generating_function x

&gt;-- | &lt;https://en.wikipedia.org/wiki/Trigonometric_functions&gt;
&gt;sin_generating_function :: (Fractional a) =&gt; Stream a
&gt;sin_generating_function = stail $ liftA2 (*) (-1 / (1+z*z)) exponential_stream

&gt;-- | &lt;https://en.wikipedia.org/wiki/Trigonometric_functions&gt;
&gt;cos_generating_function :: (Fractional a) =&gt; Stream a 
&gt;cos_generating_function = liftA2 (*) (1 / (1+z*z)) (stail $ exponential_stream)

&gt;factorial :: (Num a) =&gt; Stream a
&gt;factorial = Pre 1 $ Pre 1 $ liftA2 (*) (stail $ nonzero_naturals) (stail factorial)

&gt;-- | both reciprocal and inversion are the inverse of a Cauchy product.
&gt;-- see &lt;http://en.wikipedia.org/wiki/Formal_power_series&gt;
&gt;--
&gt;-- prop&gt; reciprocal s * s == unit_product
&gt;reciprocal :: (Fractional a) =&gt; Stream a -&gt; Stream a
&gt;reciprocal ~z'@(Pre c cr) = c `par` self
&gt;    where self = fmap (/c) $ Pre 1 (negate (cr * self))

&gt;-- | see &lt;http://en.wikipedia.org/wiki/Formal_power_series&gt;
&gt;-- 
&gt;-- prop&gt; inversion s * s == unit_product
&gt;inversion :: (Integral a) =&gt; Stream a -&gt; Stream a
&gt;inversion z'@(Pre c cr)
&gt;   | c /= 0 = let self = (fmap (`div` c) $ Pre 1 (negate (cr * self))) in self
&gt;   | otherwise = error &quot;can't invert series that begins with zero&quot;
           
&gt;quotient_invert :: (Integral a) =&gt; Stream a -&gt; Stream a
&gt;quotient_invert ~z'@(Pre c cr)
&gt;   | c /= 0 = let self = (fmap (`quot` c) $ Pre 1 (negate (cr * self))) in self
&gt;   | otherwise = error &quot;can't invert series that begins with zero&quot;

&gt;-- | unit_product is the unit element of (*) for streams.
&gt;unit_product :: (Num a) =&gt; Stream a
&gt;unit_product = fromInteger 1

&gt;-- | zero is the unit element of (+) for streams
&gt;zero :: (Num a) =&gt; Stream a
&gt;zero = return 0

&gt;stream_if :: Stream Bool -&gt; Stream a -&gt; Stream a -&gt; Stream a
&gt;stream_if = liftA3 (\c x y -&gt; if c then x else y)

&gt;either :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Stream (Either a b) -&gt; Stream c
&gt;either f g z = fmap (P.either f g) z

&gt;split_either :: Stream (Either a b) -&gt; (Stream a, Stream b)
&gt;split_either (Pre (Left x) xr) = let (a,b) = split_either xr in (Pre x a,b)
&gt;split_either (Pre (Right y) yr) = let (a,b) = split_either yr in (a,Pre y b)

&gt;split_either_bool :: Stream (Either a b) -&gt; (Stream Bool, Stream a,Stream b)
&gt;split_either_bool (Pre (Left x) xr) = let (c,a,b) = split_either_bool xr
&gt;                                  in (Pre False c,Pre x a,b)
&gt;split_either_bool (Pre (Right y) xr) = let (c,a,b) = split_either_bool xr
&gt;                                   in (Pre True c,a,Pre y b)

&gt;join_either :: Stream Bool -&gt; Stream a -&gt; Stream b -&gt; Stream (Either a b)
&gt;join_either (Pre False r) (Pre x xr) s = let r' = join_either r xr s
&gt;                                          in Pre (Left x) r'
&gt;join_either (Pre True r) s (Pre y yr) = let r' = join_either r s yr
&gt;                                         in Pre (Right y) r'

&gt;subtract :: (Num a) =&gt; Stream a -&gt; Stream a -&gt; Stream a
&gt;subtract = liftA2 Prelude.subtract

&gt;-- | add a list as a prefix to a stream
&gt;prefix :: [a] -&gt; Stream a -&gt; Stream a
&gt;prefix lst s = foldr Pre s lst

&gt;-- | The @cycle@ operation is better than @fromList@, if the list is infinite,
&gt;-- because it will ensure the result is infinite (and no Num constraint is needed).
&gt;fromList :: (Num a) =&gt; [a] -&gt; Stream a
&gt;fromList lst = prefix lst zero

&gt;toList :: Stream a -&gt; [a]
&gt;toList ~(Pre x xr) = (x:toList xr)

&gt;-- | @filter f s@ for streams does not terminate, if the input stream never
&gt;-- contains any elements @e@ for which @f e == True@.
&gt;filter :: (a -&gt; Bool) -&gt; Stream a -&gt; Stream a
&gt;filter f ~(Pre x xr) | f x = Pre x (filter f xr)
&gt;                     | otherwise = filter f xr

&gt;remove :: (Eq a) =&gt; [a] -&gt; Stream a -&gt; Stream a
&gt;remove lst = filter (`elem` lst)

&gt;-- | @interleave_count@ is like @interleave@ except that 'i' elements of each
&gt;-- stream are taken from each stream at each stream.
&gt;interleave_count :: Integer -&gt; Stream a -&gt; Stream a -&gt; Stream a
&gt;interleave_count i x y = prefix lst (interleave_count i y rest)
&gt;    where (lst,rest) = splitAt i x
                                  

&gt;uninterleave_index :: Integer -&gt; Stream a -&gt; Stream a
&gt;uninterleave_index i s = Pre x (uninterleave_index i xr)
&gt;   where Pre x xr = drop i s

&gt;-- | interleave two streams such that even indexed elements of result are
&gt;-- from first input stream and odd indexed elements of result are from
&gt;-- second stream.
&gt;interleave :: Stream a -&gt; Stream a -&gt; Stream a
&gt;interleave ~(Pre x xr) y = Pre x (interleave y xr)

&gt;-- | version of interleave that produces either instances
&gt;interleave_either :: Stream a -&gt; Stream b -&gt; Stream (Either a b)
&gt;interleave_either ~(Pre x xr) yr = Pre (Left x) (interleave_either_reverse yr xr)
&gt;  where interleave_either_reverse ~(Pre y yr') xr' = Pre (Right y) (interleave_either xr' yr')

&gt;-- | split a stream, elements with even index go to first result stream,
&gt;-- rest to second.
&gt;uninterleave :: Stream a -&gt; (Stream a, Stream a)
&gt;uninterleave ~(Pre x ~(Pre y r)) = (Pre x xr, Pre y yr)
&gt;   where ~(xr,yr) = uninterleave r

&gt;-- | three stream interleave
&gt;interleave3 :: Stream a -&gt; Stream a -&gt; Stream a -&gt; Stream a
&gt;interleave3 ~(Pre x xr) y z' = Pre x (interleave3 y z' xr)

&gt;-- | three stream uninterleave
&gt;uninterleave3 :: Stream a -&gt; (Stream a, Stream a, Stream a)
&gt;uninterleave3 ~(Pre x ~(Pre y ~(Pre z' r))) = (Pre x xr, Pre y yr, Pre z' zr)
&gt;   where ~(xr,yr,zr) = uninterleave3 r

&gt;uninterleave_indices :: Integer -&gt; Integer -&gt; Stream a -&gt; Stream a
&gt;uninterleave_indices i s = map_indices (\x -&gt; i * x + s)

&gt;-- | interleave a non-empty list of streams.
&gt;interleave_lst :: [Stream a] -&gt; Stream a
&gt;interleave_lst (Pre x xr:sr) = Pre x (interleave_lst (sr ++ [xr]))
&gt;interleave_lst [] = undefined

&gt;-- | uninterleave to an indicated number of streams.
&gt;uninterleave_lst :: Integer -&gt; Stream a -&gt; [Stream a]
&gt;uninterleave_lst i s = liftA2 Pre lst (uninterleave_lst i rst)
&gt;   where ~(lst,rst) = splitAt i s

&gt;-- | interleave a queue of streams.
&gt;interleave_queue :: (Queue :*: Stream) a -&gt; Stream a
&gt;interleave_queue (Matrix q) = case Q.dequeue q of
&gt;     (Just (~(Pre x xr),r)) -&gt; Pre x (interleave_queue (Matrix $ Q.enqueue xr r))
&gt;     Nothing                -&gt; error &quot;interleave_queue: empty queue&quot;

&gt;-- | uninterleave to a queue of streams
&gt;uninterleave_queue :: Integer -&gt; Stream a -&gt; (Queue :*: Stream) a
&gt;uninterleave_queue i s = Matrix $ liftA2 Pre (Q.fromList lst) (cells $ uninterleave_queue i rst)
&gt;       where ~(lst,rst) = splitAt i s

&gt;square :: (Num a) =&gt; [[a]] -&gt; (Stream :*: Stream) a
&gt;square = Matrix . fromList . map fromList

&gt;-- | drop a specified number of elements from beginning of a stream.
&gt;drop :: Integer -&gt; Stream a -&gt; Stream a
&gt;drop 0 x = x
&gt;drop n ~(Pre _ xr) = drop (n-1) xr

&gt;-- | take a specified number of elements from the beginning of the stream.
&gt;take :: Integer -&gt; Stream a -&gt; [a]
&gt;take 0 ~(Pre _ _) = []
&gt;take n ~(Pre x xr) = x : take (n-1) xr

&gt;-- | split a stream from index.
&gt;splitAt :: Integer -&gt; Stream a -&gt; ([a],Stream a)
&gt;splitAt i x = (take i x, drop i x)

&gt;take2d :: (Integer,Integer) -&gt; (Stream :*: Stream) a -&gt; ([] :*: []) a
&gt;take2d (x,y) m = Matrix $ m &lt;!&gt; (take x, take y)

&gt;drop2d :: (Integer,Integer) -&gt; (Stream :*: Stream) a -&gt; (Stream :*: Stream) a
&gt;drop2d (x,y) m = Matrix $ m &lt;!&gt; (drop x, drop y)

&gt;-- | count how many elements from a beginning of a stream satisfy a predicate.
&gt;countWhile :: (a -&gt; Bool) -&gt; Stream a -&gt; Integer
&gt;countWhile f (Pre x xr) | f x = succ (countWhile f xr)
&gt;                        | otherwise = 0

&gt;-- | take elements from a stream while predicate is true.
&gt;takeWhile :: (a -&gt; Bool) -&gt; Stream a -&gt; [a]
&gt;takeWhile f ~(Pre x xr) | f x = (x:takeWhile f xr)
&gt;                       | otherwise = []

&gt;-- | drop elements from a stream while predicate is true.
&gt;dropWhile :: (a -&gt; Bool) -&gt; Stream a -&gt; Stream a
&gt;dropWhile f ~z@(Pre x xr) | f x = dropWhile f xr
&gt;                         | otherwise = z

&gt;span :: (a -&gt; Bool) -&gt; Stream a -&gt; ([a],Stream a)
&gt;span f z@(Pre x xr) = if f x then (x:c,d) else ([],z)
&gt;    where (c,d) = span f xr

&gt;-- | The 'cycle' operation is better than fromList for converting a list to stream,
&gt;-- if the list is infinite, because it will ensure the result is infinite.
&gt;cycle :: [a] -&gt; Stream a
&gt;cycle lst = prefix lst (cycle lst)

&gt;-- | use elements of a queue to produce an infinite stream.
&gt;cycle_queue :: Queue a -&gt; Stream a
&gt;cycle_queue q = maybe (error &quot;empty queue&quot;) cycler (Q.dequeue q)
&gt;   where cycler (e,r) = Pre e (cycle_queue (Q.enqueue e r))

&gt;-- | stirling numbers are the numbers obtained from
&gt;-- z * (z+1) * ... * (z+n)
&gt;stirling_numbers :: (Num a) =&gt; (Stream :*: Stream) a
&gt;stirling_numbers = Matrix $ fmap (product . fmap (z +)) natural_prefixes

&gt;negative_stirling_numbers :: (Num a) =&gt; (Stream :*: Stream) a
&gt;negative_stirling_numbers = Matrix $ fmap (product . fmap (z -)) natural_prefixes

&gt;natural_prefixes :: (Num a) =&gt; Stream [a]
&gt;natural_prefixes = fmap (`take` naturals) naturals

&gt;toSquare :: (Stream :*: Stream) a -&gt; [[a]]
&gt;toSquare = take 10 . fmap (take 10) . cells

&gt;instance (PpShow a) =&gt; Show ((Stream :*: Stream) a) where
&gt;  show x = render $ print_square x

&gt;print_square :: (PpShow a) =&gt; (Stream :*: Stream) a -&gt; Doc
&gt;print_square (Matrix s) = pp_list $ take 15 $ fmap (pp_list . fmap pp . take 15) s

&gt;-- | stream of powers of a given integer for fractional items
&gt;power :: (Fractional a) =&gt; Integer -&gt; Stream a
&gt;power i = 1 / (1 - (fromInteger i * z)) 

&gt;-- | stream of powers of a given integer for integral items.
&gt;power_integral :: (Integral a) =&gt; Integer -&gt; Stream a
&gt;power_integral i = 1 `div` (1 - fromIntegral i * z)

&gt;index_powers :: (Num a) =&gt; Stream a -&gt; Stream a
&gt;index_powers a = liftA2 (^) a (naturals :: Stream Integer)

&gt;substitute :: (Num a) =&gt; Stream a -&gt; Stream a -&gt; Stream a
&gt;substitute a b = liftA2 (*) a (index_powers b)

&gt;fourier_ :: (RealFloat a) 
&gt;        =&gt; Complex a -&gt; Stream (Complex a) -&gt; Stream (Complex a)
&gt;fourier_ w s = substitute s $ constant $ exp (negate (0:+1) * w)

&gt;exp_generating_function = z*(z+1)*exp z


&gt;pre_subst :: (Num a) =&gt; Stream a -&gt; Stream a -&gt; Stream [a]
&gt;pre_subst a b = codiagonals $ Matrix $ liftA2 multiply a $ cells $ powers b

&gt;subst :: (Num a) =&gt; Stream a -&gt; Stream a -&gt; Stream a
&gt;subst a b = fmap sum $ pre_subst a b

&gt;multiply :: (Num a) =&gt; a -&gt; Stream a -&gt; Stream a
&gt;multiply x = fmap (*x)

&gt;-- | input stream elements are raised to n'th power.
&gt;powers :: (Num a) =&gt; Stream a -&gt; (Stream :*: Stream) a
&gt;powers s = Matrix $ Pre s $ fmap (liftA2 (*) s) $ cells $ powers s

&gt;-- | input element is raised to successive increasing powers
&gt;-- (first element of the stream is n^1)
&gt;cauchy_powers :: (Num a) =&gt; a -&gt; Stream a
&gt;cauchy_powers s = Pre s (fmap (s *) $ cauchy_powers s)

&gt;-- | The elements of pascal triangle are binomial coefficients.
&gt;--
&gt;-- &lt;http://en.wikipedia.org/wiki/Binomial_coefficient&gt;
&gt;binomial_coefficient :: (Integral a) =&gt; Integer -&gt; Integer -&gt; a
&gt;binomial_coefficient i j = pascal_triangle &lt;!&gt; (streamindex i,streamindex j)

&gt;generating_sqrt xplus1 = (`subst` x) $ fmap (binomial (1%2)) naturals
&gt;   where x = xplus1 - 1

&gt;-- | &lt;http://en.wikipedia.org/wiki/Catalan_number&gt;

&gt;catalan_numbers :: (Integral a) =&gt; Stream a
&gt;catalan_numbers = fmap coeff naturals
&gt;   where coeff n = binomial_coefficient (2*n) n 
&gt;                    `div` (fromInteger n + 1)

&gt;-- | &lt;http://en.wikipedia.org/wiki/Catalan_number&gt; of floating elements.
&gt;catalan_numbers_floating :: (Eq a,Floating a) =&gt; Stream a
&gt;catalan_numbers_floating = 2 / (1 + sqrt(1 - 4*z))

&gt;-- | pascal triangle, elements are binomial coefficients.
&gt;-- &lt;https://en.wikipedia.org/wiki/Pascal%27s_triangle&gt;
&gt;-- this expands &quot;down&quot; (leaving zero elements)
&gt;pascal_triangle :: (Integral a) =&gt; (Stream :*: Stream) a
&gt;pascal_triangle = Matrix $ 1 `div` (1 - z - z2*z)

&gt;-- | pascal triangle which expands towards the diagonal
&gt;pascal_triangle_diag :: (Integral a) =&gt; (Stream :*: Stream) a
&gt;pascal_triangle_diag = Matrix $ 1 `div` (1 - z - z2)

&gt;binomial_coefficients :: (Integral a) =&gt; Stream [a]
&gt;binomial_coefficients = codiagonals $ pascal_triangle_diag

&gt;exp_approx :: (Fractional a) =&gt; a -&gt; Stream a
&gt;exp_approx x = fmap (\ ~(j,lst) -&gt; let m = x / j in 
&gt;       sum $ map (\ ~(i,c) -&gt; fromIntegral c * m^^i) lst) $
&gt;       liftA2 (,) naturals $ fmap (List.zip [0..]) $ binomial_coefficients


&gt;-- | computes (a + b)^n for all n, using binomial coefficients.
&gt;--   Hint: use 'z' in one of the argument.
&gt;--   @pascal_triangle == Matrix $ polynomial_powers 1 z@
&gt;--   Note: stream_powers can sometimes be a more efficient alternative.
&gt;polynomial_powers :: (Integral a) =&gt; a -&gt; a -&gt; Stream a
&gt;polynomial_powers a b = fmap (sum . map mapper) coeffs
&gt;   where mapper (k,(a',b')) = k * (a ^ a') * (b ^ b')
&gt;         coeffs = codiagonals $ liftA2 (,) pascal_triangle_diag
&gt;                              $ matrix (,) naturals naturals

&gt;-- | a stream of fibonacci numbers,
&gt;-- each element is a sum of two previous elements.
&gt;-- @1,1,2,3,5,8,13,21,34,55,...@
&gt;fib :: (Integral a) =&gt; Stream a
&gt;fib = 1 `div` (1 - z - z*z)

&gt;-- | Triangular numbers. &lt;https://en.wikipedia.org/wiki/Generating_function&gt;
&gt;-- @1,3,6,10,15,21,28,36,...@
&gt;triangular_numbers :: (Integral a) =&gt; Stream a
&gt;triangular_numbers = 1 `div` (1 - z)^3

&gt;squares :: (Integral a) =&gt; Stream a
&gt;squares = z*(z+1)`div` (1-z)^3

&gt;-- | @1.0,-1.0,1.0,-1.0,...@
&gt;alternating_signs :: (Fractional a) =&gt; Stream a
&gt;alternating_signs = 1 / (1 + z)

&gt;-- | @1.0,0.0,1.0,0.0,1.0,0.0,...@
&gt;alternating_bits :: (Fractional a) =&gt; Stream a
&gt;alternating_bits = 1 / (1 - z*z)

&gt;alternating_possibly_negative_bits :: (Fractional a) =&gt; Stream a
&gt;alternating_possibly_negative_bits = 1 / (1 + z*z)

&gt;-- | stream of odd integers
&gt;odd_integers :: (Integral a) =&gt; Stream a
&gt;odd_integers = filter odd naturals

&gt;odd_integers_ :: (Integral a) =&gt; Stream a
&gt;odd_integers_ = 1 `div` (1 - 3*z + 4*z*z `div` (1 + z))

&gt;-- | This is an ideal of the set of integers, usually denoted nZ,
&gt;-- e.g. set of integers divisible by 'n'.

&gt;integers_divisible_by :: Integer -&gt; Stream Integer
&gt;integers_divisible_by n = Pre n $ fmap (+n) $ integers_divisible_by n

&gt;positive_residue_class_modulo :: Integer -&gt; Integer -&gt; Stream Integer
&gt;positive_residue_class_modulo m n = Pre (m `mod` n) $ fmap (+n) $ positive_residue_class_modulo m n

&gt;negative_residue_class_modulo :: Integer -&gt; Integer -&gt; Stream Integer
&gt;negative_residue_class_modulo m n = Pre (m `mod` n) $ fmap (\x -&gt; x - n) $ negative_residue_class_modulo m n

&gt;-- | This function produces the equivalence class of
&gt;-- m mod n. The numbers produced by the stream are considered
&gt;-- as equivalent by the equivalence class.

&gt;residue_class_modulo :: Integer -&gt; Integer -&gt; Stream Integer
&gt;residue_class_modulo m n = interleave (positive_residue_class_modulo m n)
&gt;                                      (stail (negative_residue_class_modulo m n))



&gt;-- | peirces_triangle is the number of set partitions.
&gt;-- From Knuth: The art of Computer Programming, Volume 4
&gt;-- &quot;Generating all combinations and partitions&quot;, page 64.

&gt;peirces_triangle_func :: (Num a, Ord a) =&gt; a -&gt; a -&gt; a
&gt;peirces_triangle_func 0 0 = 1
&gt;peirces_triangle_func 1 1 = 1
&gt;peirces_triangle_func n k | n == k = peirces_triangle_func (n-1) 1
&gt;                          | k &gt; n  = 0
&gt;                          | otherwise = peirces_triangle_func (n-1) k
&gt;                                      + peirces_triangle_func n (k+1)

&gt;-- | peirces_triangle is the number of set partitions.
&gt;-- From Knuth: The art of Computer Programming, Volume 4
&gt;-- &quot;Generating all combinations and partitions&quot;, page 64.
&gt;peirces_triangle :: (Num a, Ord a) =&gt; (Stream :*: Stream) a
&gt;peirces_triangle = matrix peirces_triangle_func nonzero_naturals nonzero_naturals

&gt;peirces_triangle_list :: (Num a, Ord a) =&gt; Stream [a]
&gt;peirces_triangle_list = fmap (takeWhile (/= 0)) $ cells peirces_triangle

&gt;-- | &lt;https://en.wikipedia.org/wiki/Injective_function?wprof=sfla1&gt;
&gt;-- falling factorial powers specify number of injective functions
&gt;-- from domain with specified number of elements to codomain with
&gt;-- specified number of elements.
&gt;-- &lt;https://en.wikipedia.org/wiki/Falling_and_rising_factorials?wprof=sfla1&gt;
&gt;--
&gt;-- Be careful about indices here, could cause off-by-one error!
&gt;falling_factorial_powers_diag = Matrix $ liftA2 (liftA2 (*)) (fmap constant factorial) (cells pascal_triangle_diag)

&gt;falling_factorial_powers :: (Eq a,Num a) =&gt; (Stream :*: Stream) a
&gt;falling_factorial_powers = matrix falling_factorial_power nonzero_naturals nonzero_naturals

&gt;rising_factorial_powers :: (Eq a,Num a) =&gt; (Stream :*: Stream) a
&gt;rising_factorial_powers = matrix rising_factorial_power nonzero_naturals nonzero_naturals

&gt;-- | bell numbers &lt;https://en.wikipedia.org/wiki/Bell_number&gt;.
&gt;-- also see Knuth: The Art of Computer Programming, Volume 4.
&gt;bell_numbers :: (Num a, Ord a) =&gt; Stream a
&gt;bell_numbers = fmap (\x -&gt; peirces_triangle_func x x) nonzero_naturals

&gt;integer_partitions_with_parts :: (Integral a) =&gt; Integer -&gt; Stream a
&gt;integer_partitions_with_parts m = z^m `div` (foldr (*) 1 $ map (\a -&gt; 1 - z^a) [1..m])

&gt;-- | newton's method of computing square root approximations:
&gt;square_root :: (Integral a) =&gt; a -&gt; Stream a
&gt;square_root i = Pre 1 $ fmap (\x -&gt; if x /= 0 then (x + (i `div` x)) `div` 2 else 0) $ square_root i

&gt;fractional_square_root :: (Fractional a, Eq a) =&gt; a -&gt; Stream a
&gt;fractional_square_root i = Pre 1 $ fmap (\x -&gt; if x /= 0 then (x + (i / x)) / 2 else 0) $ fractional_square_root i

&gt;-- | This is an implementation of Floyd's cycle-finding algorithm
&gt;-- &lt;http://en.wikipedia.org/wiki/Cycle_detection&gt;.
&gt;detect_cycle :: (Eq a) =&gt; Stream a -&gt; [a]
&gt;detect_cycle s = a : takeWhile (/= a) ar
&gt;   where (Pre a ar) = find_start (find_rep st st') s
&gt;         st = stail s
&gt;         st' = stail st
&gt;         find_rep (Pre x xr) z'@(Pre y (Pre _ yr)) 
&gt;            | x /= y = find_rep xr yr
&gt;            | otherwise = z'
&gt;         find_start (Pre x xr) z'@(Pre y yr) 
&gt;            | x /= y = find_start xr yr
&gt;            | otherwise = z'

&gt;integer_partitions :: (Integral a) =&gt; (Stream :*: Stream) a
&gt;integer_partitions = Matrix $ fmap integer_partitions_with_parts nonzero_naturals

&gt;-- | Stream of prime numbers generated using a sieve.
&gt;-- 
&gt;-- &lt;https://wiki.haskell.org/Prime_numbers&gt;
&gt;primes :: (Integral t) =&gt; Stream t
&gt;primes = Pre 2 $ Pre 3 $ sieve (stail primes) (drop 2 odd_integers)
&gt;   where sieve ~(Pre p ps) xs = prefix h $ sieve ps $ filter (filt p) t
&gt;              where ~(h,t) = span (&lt; p*p) xs
&gt;         filt p x = x `rem` p /= 0

&gt;-- | derivative calculates the derivative of the generating function.
&gt;derivative :: (Num a) =&gt; Stream a -&gt; Stream a
&gt;derivative s = liftA2 (*) nonzero_naturals (stail s)

&gt;subtract_ordered :: (Ord a) =&gt; Stream a -&gt; Stream a -&gt; Stream a
&gt;subtract_ordered z'@(Pre x xr) z''@(Pre y yr)
&gt;   | y &gt; x  = Pre x (subtract_ordered xr z'')
&gt;   | y == x = subtract_ordered xr z''
&gt;   | otherwise = subtract_ordered z' yr
  
&gt;join_ordered :: (Ord a) =&gt; Stream a -&gt; Stream a -&gt; Stream a
&gt;join_ordered z'@(Pre x xr) z''@(Pre y yr) 
&gt;    | x &lt; y = Pre x (join_ordered xr z'')
&gt;    | otherwise = Pre y (join_ordered z' yr)
  

&gt;-- | for two monotone streams, compares whether all elements of the first stream
&gt;-- are also in the second stream. produces 'True' for every element of
&gt;-- the first stream, if that element is part of the second stream.
&gt;-- produces error if the streams are not monotone.
&gt;monotonic_membership :: (Ord a) =&gt; Stream a -&gt; Stream a -&gt; Stream Bool
&gt;monotonic_membership z1@(Pre x xr) zz2@(Pre y yr)
&gt;     | x &gt; shead xr || y &gt; shead yr = fail $ &quot;Not monotonic&quot;
&gt;     | x == y = Pre True (monotonic_membership xr yr)
&gt;     | x &lt;  y = Pre False (monotonic_membership xr zz2)
&gt;     | otherwise = monotonic_membership z1 yr

&gt;-- | Square root algorithm is from
&gt;-- Simpson: Power Series, &lt;http://caps.gsfc.nasa.gov/simpson/ref/series.pdf&gt;

&gt;sqrt_stream :: (Floating a) =&gt; Stream a -&gt; Stream a
&gt;sqrt_stream z@(Pre x xr) = Pre (sqrt x) $ mprod xr (sqrt_stream z)
&gt; where pprod (a,i) (b,j) = ((i+j)-3*j)*a*b/(2*(i+j)*sqrt x)
&gt;       mprod a b = fmap sum $ codiagonals
&gt;              $ matrix pprod (a &lt;&amp;&gt; nonzero_naturals) (b &lt;&amp;&gt; naturals)

&gt;-- | &lt;https://en.wikipedia.org/wiki/Inverse_trigonometric_functions inverse trigonometric functions&gt;
&gt;-- &lt;http://en.wikipedia.org/wiki/Hyperbolic_function hyperbolic function&gt;
&gt;instance (Eq a,Floating a) =&gt; Floating (Stream a) where
&gt;  sqrt = sqrt_stream
&gt;  exp  = exponential
&gt;  log  = stream_logarithm
&gt;  sinh x = (exp x - exp (negate x)) / 2
&gt;  cosh x = (exp x + exp (negate x)) / 2
&gt;  tanh x = sinh x / cosh x
&gt;  asinh x = log (x + sqrt (x*x+1))
&gt;  acosh x = log (x + sqrt (x*x-1))
&gt;  atanh x = log ((1 + x) / (1 - x)) / 2

&gt;stream_epsilon :: (Fractional a) =&gt; (Stream :*: Stream) a
&gt;stream_epsilon = transpose $ matrix (/) nonzero_naturals nonzero_naturals --(power 2)

&gt;another_epsilon :: (Fractional a) =&gt; (Stream :*: Stream) a
&gt;another_epsilon = transpose $ matrix (/) (fmap (1/) nonzero_naturals) nonzero_naturals

&gt;-- | derivate a stream function at a particular point.
&gt;stream_derivate :: (Fractional a, Limiting a) =&gt; 
&gt;                   (Stream a -&gt; Stream a) -&gt; Stream a -&gt; Closure (Stream a)
&gt;stream_derivate f x = limit $ do
&gt;    dx &lt;- cells stream_epsilon
&gt;    return $ (f (x + dx) - f x) / dx


&gt;complex_pi :: (RealFloat a) =&gt; Stream (Complex a)
&gt;complex_pi = log (fromNum $ negate 1) / fromNum (0 :+ 1)

&gt;-- | &lt;http://en.wikipedia.org/wiki/Twin_prime&gt;

&gt;twin_primes :: (Integral a) =&gt; Stream a
&gt;twin_primes = twin_primes_stream_gen 1 primes
&gt;  where twin_primes_stream_gen prev (Pre x xr) 
&gt;          | x == prev + 2 = Pre prev (twin_primes_stream_gen x xr)
&gt;          | otherwise     = twin_primes_stream_gen x xr

&gt;-- | &lt;http://en.wikipedia.org/wiki/Formula_for_primes&gt;

&gt;gcd_primes_diff = gcd_primes - z*gcd_primes
&gt;gcd_primes = fmap gcd_prime_gen naturals
&gt;gcd_prime_gen 0 = 0
&gt;gcd_prime_gen 1 = 7
&gt;gcd_prime_gen n = p + gcd n p
&gt;    where p = gcd_prime_gen (n - 1)                                            
           
&gt;instance (Limiting a, Limiting b) =&gt; Limiting (a,b) where
&gt;  data Closure (a,b) = PairClosure (Closure a,Closure b)
&gt;  limit str = PairClosure (limit a, limit b)
&gt;      where (a,b) = funzip str
&gt;  approximations (PairClosure (x,y)) = approximations x &lt;&amp;&gt; approximations y

&gt;instance (Closed a, Closed b) =&gt; Closed (a,b) where
&gt;   accumulation_point (PairClosure (s,s')) = (accumulation_point s,
&gt;                                              accumulation_point s')

&gt;instance Limiting a =&gt; Limiting (Complex a) where
&gt;  data Closure (Complex a) = ComplexClosure { runComplexClosure :: Complex (Closure a) }
&gt;  limit str = ComplexClosure (limit a :+ limit b)
&gt;    where (a,b) = funzip $ fmap (\(a :+ b) -&gt; (a,b)) str
&gt;  approximations (ComplexClosure (a :+ b)) = liftA2 (:+) (approximations a) (approximations b)

&gt;instance (Show (Closure a)) =&gt; Show (Closure (Complex a)) where
&gt;   show (ComplexClosure r) = show r

&gt;instance (Limiting a, RealFloat a) =&gt; Num (Closure (Complex a)) where
&gt;   x + y = cliftA2 (+) x y
&gt;   x - y = cliftA2 (-) x y
&gt;   x * y = cliftA2 (*) x y
&gt;   negate x = cmap negate x
&gt;   abs x = cmap abs x
&gt;   signum x = cmap signum x
&gt;   fromInteger x = ComplexClosure (limit (constant (fromInteger x))
&gt;                                   :+ limit (constant (fromInteger 0)))


&gt;instance (Closed a) =&gt; Closed (Complex a) where
&gt;   accumulation_point (ComplexClosure (ca :+ ci)) = accumulation_point ca :+ accumulation_point ci
</span></pre></body></html>